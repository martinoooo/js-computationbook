1. Empty

   ![](https://user-gold-cdn.xitu.io/2019/8/25/16cc68ed7d77d86b?w=346&h=186&f=png&s=29061)

   这个 NFA 只接受空字符串

2. Literal

   ![](https://user-gold-cdn.xitu.io/2019/8/25/16cc68ff4bc7aa6a?w=480&h=162&f=png&s=48510)

   只接受包含那个字符的，单字符串的 NFA

3. Concatenate(串联)

   ![](https://user-gold-cdn.xitu.io/2019/8/25/16cc6a03d2b6af9d?w=922&h=360&f=png&s=143535)


    对于‘ab’字符串，我们可以把两个NFA按顺序连接到一起，用自由移动把它们连结在一起，并且保留第二个NFA的接受状态

    因此，组合机器的原材料是：

    - 第一个NFA的起始状态；
    - 第二个NFA的接受状态；
    - 两台NFA的所有规则；
    - 一些额外的自由移动，可以把第一条NFA旧的接受状态与第二个NFA旧的起始状态连接起来；

4. Choose

    ![](https://user-gold-cdn.xitu.io/2019/8/25/16cc6a9f888edf92?w=858&h=584&f=png&s=175107)

    增加一个新的起始状态并使用自由移动把它与两台原始机器之前的起始状态连接起来

    在这种情况下，组合机器的原材料是：

    - 一个新的起始状态；
    - 两台NFA的所有接受状态；
    - 两台NFA的所有规则；
    - 两个额外的自由移动，可以把新的起始状态与NFA旧的起始状态连接起来

4. Repeat

    ![](https://user-gold-cdn.xitu.io/2019/8/25/16cc6b356508c8cc?w=592&h=366&f=png&s=108701)

    我们为a*构造一个NFA，其开头是一个a对应的NFA，然后做两个补充：
    
    - 从它的接受状态到开始状态增加一个自由移动，这样它就可以与多于一个'a'匹配了；
    - 增加一个可自由移动到旧的开始状态的新状态，并且使其作为接受状态，这样它就可以匹配空字符串了

    这次我们需要：
    - 一个新的起始状态，他也是一个接受状态；
    - 旧的NFA中所有的接受状态；
    - 旧的NFA中所有的规则；
    - 一些额外的自由移动，把旧NFA的每一个接受状态与旧的起始状态连接起来；
    - 另一些自由移动，把新的起始状态与旧的起始状态连接起来
