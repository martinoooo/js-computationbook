## 确定性有限自动机

1. FARule:

   每个规则都有一个 applies_to 的方法（这个方法会返回 true 或者 false，指示这个规则是否可以在某个特定情况下应用），还有一个 follow 方法（在决定采用某条规则之后返回关于机器应该如何改变的信息）

2. DFARulebook:

   next_state 使用 FARule 里面的方法，定位到正确的规则，并找到 DFA 接下来的状态。

3. DFA:

   追踪它的当前状态，并且报告它当前是否处于接受状态。读取字符并改变状态

4. DFADesign

   一旦 DFA 获得了一些输入，它就可能不再处于其实状态了，因此我们不能再次使用它检查输入的一个新的完整序列。这意味这要从头创建它--像以前那样使用同样的起始状态、接受状态和规则手册--每当想要检查它是否接受一个新的字符串时。我们可以再一个对象里封装它的构造参数来避免手工执行这一操作。

## 非确定性有限自动机

1. NFARulebook:

   next_states 接受当前状态的一个数组和当前的字符，通过查找获取所有可能的规则，返回接下来所有可能状态的组合。

2. DFA:

   追踪它的当前状态，并且报告它当前是否处于接受状态。读取字符并改变状态。与 DFA 不同的是，它有一个当前可能的状态集合 current-states 而不是只有一个当前的确定状态 current-state,因此如果 current-states 里有一个是接受状态，就说它是处于接受状态

3. DFADesign

   自动创建新的 NFA 对象

### 自由移动

### 等价性

1. NFADesign

   修改 to_nfa 方法，增加一个可选的参数‘当前状态’，这样就可以用任意集合的当前状态构建一台 NFA，而不是只能使用 NFADesign 的起始状态。

2. NFASimulation
